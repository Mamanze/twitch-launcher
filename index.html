<html>

<head>
    <meta charset="utf-8">
    <meta name="locale" content="en">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="manifest" href="manifest.json" />
    <link rel="icon" type="image/png" href="/icons/icon-192.png" />
    <link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192.png">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/icons/icon-512.png">
    <meta name="theme-color" content="#E77200">
    <title>Twitch launcher</title>
    <style>
        body {
            font-family: system-ui;

            --mid-color: #EEE;
            --high-color: #DDD;
        }

        /* Dark theme */
        @media (prefers-color-scheme: dark) {
            body {
                background-color: black;
                color: white;
                --mid-color: #111;
                --high-color: #222;
            }
        }

        .live-only> :not(.live) {
            display: none;
        }

        .channels {
            display: grid;
            margin: 1rem;
            padding: 0;
            list-style: none;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        @media(min-width: 600px) {
            .channels {
                margin: 3rem;
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            }
        }

        .channels li {
            display: flex;
            flex-flow: column;
            background: var(--mid-color);
        }

        .channels li a {
            display: flex;
            flex-direction: row;
            flex-flow: wrap;
            align-items: center;
            justify-items: start;
            padding: 1rem;
            text-decoration: none;
            color: inherit;
            background-color: var(--high-color);
        }

        .tier {
            font-size: 1.5rem;
        }

        .name {
            flex: none;
            width: 100%;
            margin-top: .5rem;
            font-weight: bold;
        }

        .connected #connect {
            display: none;
        }

        #status {
            white-space: pre-wrap;
            margin: 1rem;
        }

        .profile-image {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            vertical-align: middle;
            margin-right: .5rem;
        }

        .emotes summary {
            padding-block: .5rem;
            cursor: pointer;
            padding-inline-start: 1rem;
            font-weight: bold;
        }

        .emote-list {
            padding: .5em;
            margin: 0;
            list-style: none;
        }

        .emote-type {
            font-weight: bold;
        }

        div:not(:first-child) .emote-type {
            padding-block: .5rem;
        }

        .emote-list dd {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(56px, 1fr));
            margin: 0;
            justify-items: start;
        }

        .emote-list li {
            display: contents;
        }

        .emote {
            display: block;
            padding: 0;
            border: 0;
            background-color: transparent;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <a href="" id="connect">Connect with Twitch</a>
    <ul id="all" class="channels live-only"></ul>

    <details class="emotes" id="all-emotes">
        <summary>Emotes (tap to copy)</summary>
        <div id="emote-container"></div>
    </details>
    <div id="status">Loading...</div>

    <script>
        const clientId = 'g4dz9iya0onjuxarj2d7ueaceq4x8w';
        const redirectUri = window.location.href;
        const scopes = "user:read:follows user:read:subscriptions user:read:emotes"
        const connectUrl = `https://id.twitch.tv/oauth2/authorize` +
            `?client_id=${clientId}` +
            `&redirect_uri=${encodeURIComponent(redirectUri)}` +
            `&response_type=token` +
            `&scope=${encodeURIComponent(scopes)}`;
        document.querySelector('#connect').setAttribute('href', connectUrl);

        const getFollowingUrl = 'https://api.twitch.tv/helix/channels/followed'; // GET user_id=
        const getStreamsFollowedUrl = 'https://api.twitch.tv/helix/streams/followed'; // GET user_id=
        const getSubscriptionsUrl = 'https://api.twitch.tv/helix/subscriptions/user'; // GET broadcaster_id=
        const getUsersUrl = 'https://api.twitch.tv/helix/users'; // GET
        const getStreamsUrl = 'https://api.twitch.tv/helix/streams'; // GET user_id=
        const getUserEmotes = 'https://api.twitch.tv/helix/chat/emotes/user'; // GET user_id= broadcaster_id=
        const getChannelEmotes = 'https://api.twitch.tv/helix/chat/emotes'; // GET broadcaster_id=



        const SCALE_SMALL = '1.0';
        const SCALE_MEDIUM = '2.0';
        const SCALE_LARGE = '3.0';

        if (window.location.hash && window.location.hash.includes('access_token')) {
            const fragmentParams = Object.fromEntries(new URLSearchParams(
                window.location.hash.substr(1) // skip the first char (#)
            ));

            setCachedData('token', fragmentParams['access_token']);

            // Clear the fragment to avoid leaking the token
            history.replaceState(null, '', window.location.pathname + window.location.search);
        }


        const channelEmotes = {};



        async function setClipboard(text) {
            const type = "text/plain";
            const clipboardItemData = {
                [type]: text,
            };
            const clipboardItem = new ClipboardItem(clipboardItemData);
            await navigator.clipboard.write([clipboardItem]);
        }

        async function getCachedToken() {
            const cachedToken = getCachedData('token', 60 * 24 * 7); // 7 days
            if (!cachedToken.found) {
                return null;
            }

            if (cachedToken.value == null) {
                return null;
            }

            const valid = await fetch('https://id.twitch.tv/oauth2/validate', {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${cachedToken.value}`,
                }
            }).catch(() => {
                return null;
            });

            if (!valid.ok) {
                localStorage.removeItem('token');
                return null;
            }

            return cachedToken.value;
        }

        function getCachedData(key, expiryInMinutes) {
            const cached = localStorage.getItem(key);
            if (!cached) return { value: null, found: false };

            const { value, timestamp } = JSON.parse(cached);
            const now = Date.now();
            if ((now - timestamp) < expiryInMinutes * 60 * 1000) {
                return { value, found: true }; // Cache is still valid
            }

            localStorage.removeItem(key); // Expired cache
            return { value: null, found: false };
        }

        function setCachedData(key, value) {
            const dataToStore = {
                value,
                timestamp: Date.now()
            };
            localStorage.setItem(key, JSON.stringify(dataToStore));
        }

        async function fetchData(url, useCache = false, cacheExpiryInMinutes = 5, cacheNulls = false, keyOverride = null) {
            const key = keyOverride ?? url;

            if (useCache) {
                const cached = getCachedData(key, cacheExpiryInMinutes);
                if (cached.found) return cached.value;

                // slow down these requests to avoid rate limiting
                await new Promise((resolve) => {
                    setTimeout(() => resolve(), 20);
                });
            }

            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Client-Id': `${clientId}`
                }
            });

            if (!response.ok) {
                if (response.status === 429) {
                    // Rate limited, wait and retry
                    const retryAfter = parseInt(response.headers.get('Retry-After') || '1', 10);
                    await new Promise((resolve) => {
                        setTimeout(() => resolve(), (retryAfter + 1) * 1000);
                    });
                    return fetchData(url, useCache, cacheExpiryInMinutes, cacheNulls, keyOverride);
                }


                if (useCache && cacheNulls && response.status === 404) {
                    setCachedData(key, null);
                    return null;
                }
                if (response.status === 401) {
                    // Unauthorized, clear token
                    setCachedData('token', null);
                    return null;
                    window.location.reload();
                }
            }
            const data = await response.json();

            if (useCache) {
                setCachedData(key, data);
            }

            return data;
        }

        function fetchUserData() {
            return fetchData(getUsersUrl, keyOverride = 'user').then((response) => {
                const { data } = response ?? {};
                return data[0];
            });
        }

        async function fetchFollowing(userId, after, forceRefresh = false) {
            let url = getStreamsFollowedUrl +
                `?user_id=${encodeURIComponent(userId)}`
                + `&first=100`;

            if (after) {
                url += `&after=${encodeURIComponent(after)}`;
            }

            const response = await fetchData(url, false).catch(() => null);

            const { data, pagination, total } = response ?? {};
            const ul = document.querySelector('#all');
            data?.forEach(async follow => {
                const li = ul.appendChild(document.createElement('li'));

                li.id = `follow-${follow.user_id}`;
                li.dataset.sortKey = '0';

                if (follow.type === 'live') {
                    li.classList.add('live');
                    li.dataset.sortKey = '10000';
                }

                li.dataset.id = follow.user_id;
                li.dataset.name = follow.user_name;

                updateLink(li);
            });
            if (pagination?.cursor) {
                return fetchFollowing(userId, pagination.cursor);
            }
            return Promise.resolve();
        }

        function getTier(subData) {
            switch (subData.tier) {
                case '1000':
                    return 'ðŸ’“';
                case '2000':
                    return 'ðŸ’–';
                case '3000':
                    return 'â¤ï¸â€ðŸ”¥';
                default:
                    return '';
            }
        }

        function updateLink(li) {
            const link = document.createElement('a');
            link.href = `https://twitch.tv/${li.dataset.name}`;

            if (li.dataset.profileImageUrl) {
                // li.dataset.profileImageUrl = 'https://static-cdn.jtvnw.net/jtv_user_pictures/twitchtv-profile_image-300x300.png';
                const img = link.appendChild(document.createElement('img'));
                img.src = li.dataset.profileImageUrl;
                img.alt = `${li.dataset.name} profile image`;
                img.className = 'profile-image';
            }

            if (li.dataset.tier) {
                const isGift = li.dataset.isGift === 'true';

                li.classList.add(`tier-${li.dataset.tier / 1000}`);
                li.classList.toggle('gift', isGift);

                const tier = link.appendChild(document.createElement('span'));
                tier.className = 'tier';
                tier.textContent = getTier({ tier: li.dataset.tier }) + (isGift ? ' ðŸŽ' : '');
            } else {
                li.classList.remove('tier-1', 'tier-2', 'tier-3');
            }

            const name = link.appendChild(document.createElement('span'));
            name.textContent = li.dataset.name;
            name.classList.add('name');

            [...li.children].forEach(child => li.removeChild(child));
            li.appendChild(link);
        }

        function checkSubscriptions(userId, channelIds, forceRefresh = false) {
            channelIds.forEach(async broadcasterId => {
                const url = `${getSubscriptionsUrl}` +
                    `?broadcaster_id=${encodeURIComponent(broadcasterId)}` +
                    `&user_id=${encodeURIComponent(userId)}`

                const response = await fetchData(url, !forceRefresh, 120, true, `sub${broadcasterId}`).catch(() => null);

                if (!response) {
                    // not subscribed
                    return;
                }

                const { data } = response ?? {};
                if (data?.length) {
                    const li = document.querySelector(`#follow-${broadcasterId}`);

                    const { tier, is_gift } = data[0];

                    li.classList.add('subscribed');

                    let sortKey = parseInt(li.dataset.sortKey || '0', 10);
                    sortKey += parseInt(tier || '0', 10);

                    if (!is_gift) {
                        sortKey += 500; // gifts go before non-gifts of same tier
                    }
                    li.dataset.tier = tier;
                    li.dataset.isGift = is_gift;
                    li.dataset.sortKey = sortKey;

                    updateLink(li);
                }
            });

            sortList('all');

        }

        // Currently not used, switched to streams/followed endpoint which includes live status
        async function checkLiveStatuses(channelIds) {
            const chunkSize = 100; // Twitch API limit
            for (let i = 0; i < channelIds.length; i += chunkSize) {
                const chunk = channelIds.slice(i, i + chunkSize);
                function fetchPage(cursor) {
                    let url = getStreamsUrl + `?user_id=${chunk.map(id => encodeURIComponent(id)).join('&user_id=')}` +
                        `&type=live` +
                        `&first=100`;
                    if (cursor) {
                        url += `&after=${encodeURIComponent(cursor)}`;
                    }

                    return fetchData(url, false).then(response => {
                        const { data, pagination } = response ?? {};
                        data.forEach(stream => {
                            const li = document.querySelector(`#follow-${stream.user_id}`);
                            if (li) {
                                li.classList.toggle('live', true);
                                li.dataset.sortKey = parseInt(li.dataset.sortKey || '0', 10) + 10000; // live goes to top
                            }
                        });
                        if (pagination?.cursor) {
                            return fetchPage(pagination.cursor);
                        } else {
                            return Promise.resolve;
                        }
                    }).then(() => {
                        sortList('all');
                    });
                }
                await fetchPage('');
            }
        }

        async function fetchChannelImages(channelIds, forceRefresh = false) {
            const chunkSize = 100; // Twitch API limit
            for (let i = 0; i < channelIds.length; i += chunkSize) {
                const chunk = channelIds.slice(i, i + chunkSize);

                let url = getUsersUrl +
                    `?id=${chunk.map(id => encodeURIComponent(id)).join('&id=')}` +
                    `&first=100`;

                await fetchData(url, !forceRefresh, 240).then(response => {
                    const { data } = response ?? {};
                    data?.forEach(user => {
                        const li = document.querySelector(`#follow-${user.id}`);

                        if (li) {
                            li.dataset.profileImageUrl = user.profile_image_url;
                            updateLink(li);
                        }
                    });
                });
            }
        }

        function pickScale(emote, scale) {
            if (emote.scale.includes(scale)) {
                return scale;
            }
            const hasMedium = emote.scale.includes(SCALE_MEDIUM);
            // want small, try medium then large
            if (scale === SCALE_SMALL) {
                if (hasMedium) {
                    return SCALE_MEDIUM;
                }
                return SCALE_LARGE;
            }
            // want medium, try large then small
            if (scale === SCALE_MEDIUM) {
                if (emote.scale.includes(SCALE_LARGE)) {
                    return SCALE_LARGE;
                }
                return SCALE_SMALL;
            }
            // want large, try medium then small
            if (hasMedium) {
                return SCALE_MEDIUM;
            }
            return SCALE_SMALL;
        }

        function pickFormat(emote) {
            if (emote.format.includes('animated')) {
                return 'animated';
            }
            return 'static';
        }

        function pickTheme(emote) {
            const prefersDark = !!window.matchMedia('(prefers-color-scheme: dark)')?.matches;
            if (prefersDark && emote.theme_mode.includes('dark')) {
                return 'dark';
            }
            if (!prefersDark && emote.theme_mode.includes('light')) {
                return 'light';
            }
            return emote.theme_mode[0];
        }

        function buildEmoteUrl(template, emote, scale) {
            let url = template;
            url = url.replace('{{id}}', emote.id);
            url = url.replace('{{scale}}', pickScale(emote, scale));
            url = url.replace('{{theme_mode}}', pickTheme(emote));
            url = url.replace('{{format}}', pickFormat(emote));
            return url;
        }

        function getEmoteType(emote) {
            switch (emote.emote_type) {
                case 'follower':
                    return { key: 'follower', name: 'Follower', sortKey: 80000 };
                case 'bitstier':
                    return { key: 'bits', name: 'Bits', sortKey: 90000 };
                case 'subscriptions':
                    return { key: `sub`, name: `Sub`, sortKey: 100000 };
                case 'channelpoints':
                    return { key: 'channelpoints', name: 'Channel Points', sortKey: 70000 };
                case 'rewards':
                    return { key: 'rewards', name: 'Rewards', sortKey: 60000 };
                case 'hypetrain':
                    return { key: 'hypetrain', name: 'Hype Train', sortKey: 50000 };
                default:
                    return { key: 'other', name: 'Other', sortKey: -1 };
            }
        }

        function buildEmoteList(emotes, template, container) {
            container.querySelector('.emote-list')?.remove();
            const emotesList = container.appendChild(document.createElement('dl'));
            emotesList.classList.add('emote-list');

            const types = {};

            emotes.forEach(emote => {
                const emoteType = getEmoteType(emote);
                if (!types[emoteType.key]) {
                    const type = emotesList.appendChild(document.createElement('div'));
                    type.dataset.sortKey = emoteType.sortKey;

                    const dt = type.appendChild(document.createElement('dt'));
                    dt.classList.add('emote-type');
                    dt.textContent = emoteType.name;

                    const dd = type.appendChild(document.createElement('dd'));
                    types[emoteType.key] = dd;
                }

                const mediumUrl = buildEmoteUrl(template, emote, SCALE_MEDIUM);
                const largeUrl = buildEmoteUrl(template, emote, SCALE_LARGE);
                const button = types[emoteType.key]
                    .appendChild(document.createElement('button'));
                button.addEventListener('click', async () => {
                    await setClipboard(emote.name);
                });
                button.type = 'button';
                button.classList.add('emote');
                button.title = emote.name;
                const image = button.appendChild(document.createElement('img'));
                image.src = mediumUrl;
            })
        }

        async function fetchAllEmotes(userId, forceRefresh = false) {
            let aTemplate = '';

            function fetchPage(cursor) {
                let key = 'allEmotes';
                let url = `${getUserEmotes}` +
                    `?user_id=${encodeURIComponent(userId)}`;

                if (cursor) {
                    url += `&after=${encodeURIComponent(cursor)}`;
                    key += `-${cursor}`;
                }

                return fetchData(url, !forceRefresh, 120, keyOverride = key).then(response => {
                    const { data, pagination, template } = response ?? {};
                    aTemplate = template;

                    let allEmotes = data ?? [];
                    if (pagination?.cursor) {
                        return fetchPage(pagination.cursor).then(nextEmotes => {
                            allEmotes = allEmotes.concat(nextEmotes);
                            return allEmotes;
                        });
                    } else {
                        return allEmotes;
                    }
                });
            }

            const allEmotes = await fetchPage('');

            allEmotes.forEach(emote => {
                if (!emote.owner_id) return; // skip personal emotes
                channelEmotes[emote.owner_id] = channelEmotes[emote.owner_id] || [];
                channelEmotes[emote.owner_id].push(emote);
            });

            buildEmoteList(allEmotes, aTemplate, document.getElementById('all-emotes'));

            sortList(document.getElementById('all-emotes').querySelector('.emote-list'));

            document.querySelectorAll('#all li').forEach(li => {
                li.querySelector('.emotes')?.remove();

                const emotes = channelEmotes[li.dataset.id];
                if (emotes) {
                    const emoteDetails = li.appendChild(document.createElement('details'));
                    emoteDetails.classList.add('emotes');
                    const summary = emoteDetails.appendChild(document.createElement('summary'));
                    summary.textContent = `Emotes (${emotes.length})`;

                    buildEmoteList(emotes, aTemplate, emoteDetails);

                    sortList(emoteDetails.querySelector('.emote-list'));
                }
            });
        }

        function sortList(parent) {
            const list = typeof parent === 'string' ? document.querySelector(`#${parent}`) : parent;
            if (!list) return;
            const items = Array.from(list.children);
            items.sort((a, b) => {
                const keyA = parseInt(a.dataset.sortKey || '0', 10);
                const keyB = parseInt(b.dataset.sortKey || '0', 10);
                return keyB - keyA; // higher tier first
            });
            items.forEach(item => list.appendChild(item));
        }

        let token = null;

        (async () => {
            token = await getCachedToken();
            if (token) {
                document.body.classList.add('connected');
                const status = document.getElementById('status');
                fetchUserData().then(async userData => {
                    status.textContent += ` Connected as ${userData.display_name}\n`;
                    status.textContent += 'Fetching following...';
                    await fetchFollowing(userData.id);
                    const allChannelIds = Array.from(document.querySelectorAll('#all li')).map(li => li.dataset.id);
                    status.textContent += ` Done, following ${allChannelIds.length}.\n`;
                    status.textContent += 'Checking subscriptions...';
                    await checkSubscriptions(userData.id, allChannelIds);
                    status.textContent += ' Done.\n';
                    // status.textContent += 'Checking live statuses...';
                    // await checkLiveStatuses(allChannelIds);
                    // status.textContent += ' Done.\n';
                    status.textContent += 'Grabbing images...';
                    await fetchChannelImages(allChannelIds);
                    status.textContent += ' Done.\n';
                    status.textContent += 'Fetching emotes...';
                    await fetchAllEmotes(userData.id);
                    status.textContent += ' Done.\n';
                    status.textContent += 'All data loaded.';
                });
            }

        })();
    </script>
</body>

</html>